{"version":3,"file":"index.umd.js","sources":["../src/index.mjs"],"sourcesContent":["/**\n * Uses Intersection Observer to monitor the page location of a series of\n * elements for scrollytelling.\n *\n * @param {object} options\n * @param {Element} [options.container] Optionally pass in what should be\n * considered the containing element of all the scenes - this gets added to the\n * Intersection Observer instance and additionally fires its own events\n * @param {Number} [options.offset] How far from the top/bottom of the viewable\n * area to trigger enters/exits of scenes, represented as a value between\n * 0 and 1\n * @param {Element[]} options.scenes An array of all the Elements to be\n * considered scenes of this Scroller\n * @property {IntersectionObserver|null} observer Once initialized, a reference\n * to the Scroller's instance of IntersectionObserver\n * @example\n *\n * import Scroller from '@newswire/scroller';\n *\n * const scroller = new Scroller({\n *   scenes: document.querySelectorAll('.scenes')\n * });\n *\n * scroller.init();\n */\nclass Scroller {\n  constructor({ container, offset = 0.5, scenes }) {\n    // public\n    this.observer = null;\n\n    // private\n    this.all_ = {};\n    this.container_ = container;\n    this.offset_ = offset;\n    this.previousOffset_ = 0;\n    this.scenes_ = scenes;\n  }\n\n  /**\n   * Adds a callback to the queue of a given event listener.\n   *\n   * @param {string} type Name of the event\n   * @param {Function} handler Callback function added to the listener\n   * @returns {void}\n   * @example\n   *\n   * const scroller = new Scroller({\n   *   scenes: document.querySelectorAll('.scenes')\n   * });\n   *\n   * const fn = (...) => {...};\n   *\n   * // adds callback to listener\n   * scroller.on('scene:enter', fn);\n   */\n  on(type, handler) {\n    (this.all_[type] || (this.all_[type] = [])).push(handler);\n  }\n\n  /**\n   * Removes a callback from the queue of a given event listener.\n   *\n   * @param {string} type Name of the event\n   * @param {Function} handler Callback function removed from the listener\n   * @returns {void}\n   * @example\n   *\n   * const scroller = new Scroller({\n   *   scenes: document.querySelectorAll('.scenes')\n   * });\n   *\n   * const fn = (...) => {...};\n   *\n   * // adds callback to listener\n   * scroller.on('scene:enter', fn);\n   *\n   * // removes callback from listener\n   * scroller.off('scene:enter', fn);\n   */\n  off(type, handler) {\n    if (this.all_[type]) {\n      this.all_[type].splice(this.all_[type].indexOf(handler) >>> 0, 1);\n    }\n  }\n\n  /**\n   * Sends a payload to all callback functions listening for a given event.\n   *\n   * @private\n   * @param {string} type Name of the event\n   * @param {*} evt Data to be sent to each callback attached to the listener\n   * @returns {void}\n   */\n  emit_(type, evt) {\n    (this.all_[type] || []).slice().map(handler => {\n      handler(evt);\n    });\n  }\n\n  /**\n   * Initializes a Scroller's IntersectionObserver on a page and begins sending\n   * any intersection events that occur.\n   *\n   * @returns {void}\n   * @example\n   *\n   * const scroller = new Scroller({\n   *   scenes: document.querySelectorAll('.scenes')\n   * });\n   *\n   * scroller.init();\n   */\n  init() {\n    const observed = [];\n\n    const marginTop = Math.ceil(-100 * (1 - this.offset_));\n    const marginBottom = Math.ceil(-100 * this.offset_);\n\n    this.observer = new IntersectionObserver(\n      entries => {\n        const isScrollingDown = this.getDirection_();\n\n        entries.forEach(entry => {\n          const element = entry.target;\n\n          const payload = {\n            bounds: entry.boundingClientRect,\n            element,\n            index: observed.indexOf(element),\n            isScrollingDown,\n          };\n\n          const prefix = element === this.container_ ? 'container' : 'scene';\n\n          if (entry.isIntersecting) {\n            /**\n             * Container enter event. Fires whenever the container begins intersecting.\n             *\n             * @event Scroller#container:enter\n             * @type {object}\n             * @property {DOMRectReadOnly} bounds The bounds of the active element\n             * @property {Element} element The element that intersected\n             * @property {number} index This is always -1 on the container\n             * @property {boolean} isScrollingDown Whether the user triggered this element\n             * while scrolling down or not\n             */\n            /**\n             * Scene enter event. Fires whenever a scene begins intersecting.\n             *\n             * @event Scroller#scene:enter\n             * @type {object}\n             * @property {DOMRectReadOnly} bounds The bounds of the active element\n             * @property {Element} element The element that intersected\n             * @property {number} index The index of the active element\n             * @property {boolean} isScrollingDown Whether the user triggered this element\n             * while scrolling down or not\n             */\n            this.emit_(`${prefix}:enter`, payload);\n          } else {\n            /**\n             * Container exit event. Fires whenever the container has exited.\n             *\n             * @event Scroller#container:exit\n             * @type {object}\n             * @property {DOMRectReadOnly} bounds The bounds of the exiting element\n             * @property {Element} element The element that exited\n             * @property {number} index This is always -1 on the container\n             * @property {boolean} isScrollingDown Whether the user triggering the exit\n             * while scrolling down or not\n             */\n            /**\n             * Scene enter event. Fires whenever a scene has exited.\n             *\n             * @event Scroller#scene:exit\n             * @type {object}\n             * @property {DOMRectReadOnly} bounds The bounds of the exiting element\n             * @property {Element} element The element that exited\n             * @property {number} index The index of the exiting element\n             * @property {boolean} isScrollingDown Whether the user triggering the exit\n             * while scrolling down or not\n             */\n            this.emit_(`${prefix}:exit`, payload);\n          }\n        });\n      },\n      {\n        rootMargin: `${marginTop}% 0px ${marginBottom}%`,\n      }\n    );\n\n    for (let i = 0; i < this.scenes_.length; i++) {\n      const item = this.scenes_[i];\n\n      observed.push(item);\n      this.observer.observe(item);\n    }\n\n    // a container is not required, but if provided we'll track it\n    if (this.container_) this.observer.observe(this.container_);\n\n    /**\n     * Init event. Fires once Scroller has finished setting up.\n     *\n     * @event Scroller#init\n     */\n    this.emit_('init');\n  }\n\n  /**\n   * Determines whether the page was scrolling up or down when an intersection\n   * event is triggered. Keeps track of direction via storage of the previous\n   * pageYOffset.\n   *\n   * @private\n   * @returns {boolean} If true, the page was scrolling down\n   */\n  getDirection_() {\n    const currentOffset = window.pageYOffset;\n\n    const isScrollingDown = currentOffset > this.previousOffset_;\n    this.previousOffset_ = currentOffset;\n\n    return isScrollingDown;\n  }\n}\n\nexport default Scroller;\n"],"names":["Scroller","constructor","ref","observer","all_","container_","container","offset_","offset","previousOffset_","scenes_","scenes","on","type","handler","this","push","off","splice","indexOf","emit_","evt","slice","map","init","observed","marginTop","Math","ceil","marginBottom","IntersectionObserver","entries","isScrollingDown","getDirection_","forEach","entry","element","target","payload","bounds","boundingClientRect","index","prefix","isIntersecting","rootMargin","let","i","length","item","observe","currentOffset","window","pageYOffset"],"mappings":"uKAyBA,IAAMA,EACJC,SAAYC,+CAAsB,wBAE3BC,SAAW,UAGXC,EAAO,QACPC,EAAaC,OACbC,EAAUC,OACVC,EAAkB,OAClBC,EAAUC,UAoBjBC,YAAAA,YAAGC,EAAMC,IACNC,KAAKX,EAAKS,KAAUE,KAAKX,EAAKS,GAAQ,KAAKG,KAAKF,IAuBnDG,YAAAA,aAAIJ,EAAMC,GACJC,KAAKX,EAAKS,SACPT,EAAKS,GAAMK,OAAOH,KAAKX,EAAKS,GAAMM,QAAQL,KAAa,EAAG,IAYnEM,YAAAA,WAAMP,EAAMQ,IACTN,KAAKX,EAAKS,IAAS,IAAIS,QAAQC,aAAIT,GAClCA,EAAQO,MAiBZG,YAAAA,2BACQC,EAAW,GAEXC,EAAYC,KAAKC,MAAM,KAAO,EAAIb,KAAKR,IACvCsB,EAAeF,KAAKC,MAAM,IAAMb,KAAKR,QAEtCJ,SAAW,IAAI2B,8BAClBC,OACQC,EAAkBjB,EAAKkB,IAE7BF,EAAQG,iBAAQC,OACRC,EAAUD,EAAME,OAEhBC,EAAU,CACdC,OAAQJ,EAAMK,2BACdJ,EACAK,MAAOhB,EAASN,QAAQiB,mBACxBJ,GAGIU,EAASN,IAAYrB,EAAKV,EAAa,YAAc,UAyBpDe,EAvBHe,EAAMQ,eAuBMD,WAwBAA,UAxBgBJ,MA4BpC,CACEM,WAAelB,WAAkBG,YAIhCgB,IAAIC,EAAI,EAAGA,EAAI/B,KAAKL,EAAQqC,OAAQD,IAAK,KACtCE,EAAOjC,KAAKL,EAAQoC,GAE1BrB,EAAST,KAAKgC,QACT7C,SAAS8C,QAAQD,GAIpBjC,KAAKV,GAAYU,KAAKZ,SAAS8C,QAAQlC,KAAKV,QAO3Ce,EAAM,SAWba,YAAAA,iBACQiB,EAAgBC,OAAOC,YAEvBpB,EAAkBkB,EAAgBnC,KAAKN,cACxCA,EAAkByC,EAEhBlB"}